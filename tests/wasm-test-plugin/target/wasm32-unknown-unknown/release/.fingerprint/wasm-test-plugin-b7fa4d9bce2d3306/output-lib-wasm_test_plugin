{"$message_type":"diagnostic","message":"cannot find struct, variant or union type `CompositeTreeRecord` in this scope","code":{"code":"E0422","explanation":"An identifier that is neither defined nor a struct was used.\n\nErroneous code example:\n\n```compile_fail,E0422\nfn main () {\n    let x = Foo { x: 1, y: 2 };\n}\n```\n\nIn this case, `Foo` is undefined, so it inherently isn't anything, and\ndefinitely not a struct.\n\n```compile_fail\nfn main () {\n    let foo = 1;\n    let x = foo { x: 1, y: 2 };\n}\n```\n\nIn this case, `foo` is defined, but is not a struct, so Rust can't use it as\none.\n"},"level":"error","spans":[{"file_name":"/home/runner/work/busbar-sf-api/busbar-sf-api/crates/sf-wasm-types/src/lib.rs","byte_start":11645,"byte_end":11675,"line_start":371,"line_end":371,"column_start":1,"column_end":31,"is_primary":false,"text":[{"text":"pub struct CompositeTreeResult {","highlight_start":1,"highlight_end":31}],"label":"similarly named struct `CompositeTreeResult` defined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":10867,"byte_end":10886,"line_start":310,"line_end":310,"column_start":23,"column_end":42,"is_primary":true,"text":[{"text":"        records: vec![CompositeTreeRecord {","highlight_start":23,"highlight_end":42}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"a struct with a similar name exists","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":10867,"byte_end":10886,"line_start":310,"line_end":310,"column_start":23,"column_end":42,"is_primary":true,"text":[{"text":"        records: vec![CompositeTreeRecord {","highlight_start":23,"highlight_end":42}],"label":null,"suggested_replacement":"CompositeTreeResult","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0422]\u001b[0m\u001b[1m: cannot find struct, variant or union type `CompositeTreeRecord` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:310:23\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m310\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         records: vec![CompositeTreeRecord {\n    \u001b[1m\u001b[94m|\u001b[0m                       \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mhelp: a struct with a similar name exists: `CompositeTreeResult`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/home/runner/work/busbar-sf-api/busbar-sf-api/crates/sf-wasm-types/src/lib.rs:371:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m371\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct CompositeTreeResult {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m------------------------------\u001b[0m \u001b[1m\u001b[94msimilarly named struct `CompositeTreeResult` defined here\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find struct, variant or union type `CompositeTreeAttributes` in this scope","code":{"code":"E0422","explanation":"An identifier that is neither defined nor a struct was used.\n\nErroneous code example:\n\n```compile_fail,E0422\nfn main () {\n    let x = Foo { x: 1, y: 2 };\n}\n```\n\nIn this case, `Foo` is undefined, so it inherently isn't anything, and\ndefinitely not a struct.\n\n```compile_fail\nfn main () {\n    let foo = 1;\n    let x = foo { x: 1, y: 2 };\n}\n```\n\nIn this case, `foo` is defined, but is not a struct, so Rust can't use it as\none.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":10913,"byte_end":10936,"line_start":311,"line_end":311,"column_start":25,"column_end":48,"is_primary":true,"text":[{"text":"            attributes: CompositeTreeAttributes {","highlight_start":25,"highlight_end":48}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0422]\u001b[0m\u001b[1m: cannot find struct, variant or union type `CompositeTreeAttributes` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:311:25\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m311\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             attributes: CompositeTreeAttributes {\n    \u001b[1m\u001b[94m|\u001b[0m                         \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find struct, variant or union type `ParameterizedSearchRequest` in this scope","code":{"code":"E0422","explanation":"An identifier that is neither defined nor a struct was used.\n\nErroneous code example:\n\n```compile_fail,E0422\nfn main () {\n    let x = Foo { x: 1, y: 2 };\n}\n```\n\nIn this case, `Foo` is undefined, so it inherently isn't anything, and\ndefinitely not a struct.\n\n```compile_fail\nfn main () {\n    let foo = 1;\n    let x = foo { x: 1, y: 2 };\n}\n```\n\nIn this case, `foo` is defined, but is not a struct, so Rust can't use it as\none.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":22987,"byte_end":23013,"line_start":651,"line_end":651,"column_start":19,"column_end":45,"is_primary":true,"text":[{"text":"    let request = ParameterizedSearchRequest {","highlight_start":19,"highlight_end":45}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0422]\u001b[0m\u001b[1m: cannot find struct, variant or union type `ParameterizedSearchRequest` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:651:19\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m651\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let request = ParameterizedSearchRequest {\n    \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find struct, variant or union type `BulkJobRequest` in this scope","code":{"code":"E0422","explanation":"An identifier that is neither defined nor a struct was used.\n\nErroneous code example:\n\n```compile_fail,E0422\nfn main () {\n    let x = Foo { x: 1, y: 2 };\n}\n```\n\nIn this case, `Foo` is undefined, so it inherently isn't anything, and\ndefinitely not a struct.\n\n```compile_fail\nfn main () {\n    let foo = 1;\n    let x = foo { x: 1, y: 2 };\n}\n```\n\nIn this case, `foo` is defined, but is not a struct, so Rust can't use it as\none.\n"},"level":"error","spans":[{"file_name":"/home/runner/work/busbar-sf-api/busbar-sf-api/crates/sf-wasm-types/src/lib.rs","byte_start":16285,"byte_end":16312,"line_start":519,"line_end":519,"column_start":1,"column_end":28,"is_primary":false,"text":[{"text":"pub struct BulkJobIdRequest {","highlight_start":1,"highlight_end":28}],"label":"similarly named struct `BulkJobIdRequest` defined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":27525,"byte_end":27539,"line_start":773,"line_end":773,"column_start":26,"column_end":40,"is_primary":true,"text":[{"text":"    let create_request = BulkJobRequest {","highlight_start":26,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"a struct with a similar name exists","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":27525,"byte_end":27539,"line_start":773,"line_end":773,"column_start":26,"column_end":40,"is_primary":true,"text":[{"text":"    let create_request = BulkJobRequest {","highlight_start":26,"highlight_end":40}],"label":null,"suggested_replacement":"BulkJobIdRequest","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0422]\u001b[0m\u001b[1m: cannot find struct, variant or union type `BulkJobRequest` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:773:26\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m773\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let create_request = BulkJobRequest {\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mhelp: a struct with a similar name exists: `BulkJobIdRequest`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/home/runner/work/busbar-sf-api/busbar-sf-api/crates/sf-wasm-types/src/lib.rs:519:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m519\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct BulkJobIdRequest {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m---------------------------\u001b[0m \u001b[1m\u001b[94msimilarly named struct `BulkJobIdRequest` defined here\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find struct, variant or union type `BulkQueryJobRequest` in this scope","code":{"code":"E0422","explanation":"An identifier that is neither defined nor a struct was used.\n\nErroneous code example:\n\n```compile_fail,E0422\nfn main () {\n    let x = Foo { x: 1, y: 2 };\n}\n```\n\nIn this case, `Foo` is undefined, so it inherently isn't anything, and\ndefinitely not a struct.\n\n```compile_fail\nfn main () {\n    let foo = 1;\n    let x = foo { x: 1, y: 2 };\n}\n```\n\nIn this case, `foo` is defined, but is not a struct, so Rust can't use it as\none.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":29085,"byte_end":29104,"line_start":823,"line_end":823,"column_start":19,"column_end":38,"is_primary":true,"text":[{"text":"    let request = BulkQueryJobRequest {","highlight_start":19,"highlight_end":38}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0422]\u001b[0m\u001b[1m: cannot find struct, variant or union type `BulkQueryJobRequest` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:823:19\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m823\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let request = BulkQueryJobRequest {\n    \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find struct, variant or union type `ListMetadataQuery` in this scope","code":{"code":"E0422","explanation":"An identifier that is neither defined nor a struct was used.\n\nErroneous code example:\n\n```compile_fail,E0422\nfn main () {\n    let x = Foo { x: 1, y: 2 };\n}\n```\n\nIn this case, `Foo` is undefined, so it inherently isn't anything, and\ndefinitely not a struct.\n\n```compile_fail\nfn main () {\n    let foo = 1;\n    let x = foo { x: 1, y: 2 };\n}\n```\n\nIn this case, `foo` is defined, but is not a struct, so Rust can't use it as\none.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":31999,"byte_end":32016,"line_start":906,"line_end":906,"column_start":17,"column_end":34,"is_primary":true,"text":[{"text":"    let query = ListMetadataQuery {","highlight_start":17,"highlight_end":34}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0422]\u001b[0m\u001b[1m: cannot find struct, variant or union type `ListMetadataQuery` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:906:17\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m906\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let query = ListMetadataQuery {\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `Deserialize`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/lib.rs","byte_start":523,"byte_end":534,"line_start":16,"line_end":16,"column_start":13,"column_end":24,"is_primary":true,"text":[{"text":"use serde::{Deserialize, Serialize};","highlight_start":13,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":523,"byte_end":536,"line_start":16,"line_end":16,"column_start":13,"column_end":26,"is_primary":true,"text":[{"text":"use serde::{Deserialize, Serialize};","highlight_start":13,"highlight_end":26}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/lib.rs","byte_start":522,"byte_end":523,"line_start":16,"line_end":16,"column_start":12,"column_end":13,"is_primary":true,"text":[{"text":"use serde::{Deserialize, Serialize};","highlight_start":12,"highlight_end":13}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/lib.rs","byte_start":545,"byte_end":546,"line_start":16,"line_end":16,"column_start":35,"column_end":36,"is_primary":true,"text":[{"text":"use serde::{Deserialize, Serialize};","highlight_start":35,"highlight_end":36}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `Deserialize`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:16:13\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use serde::{Deserialize, Serialize};\n   \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[33m^^^^^^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":4677,"byte_end":4692,"line_start":143,"line_end":143,"column_start":47,"column_end":62,"is_primary":true,"text":[{"text":"    let get_result = match get(\"Account\", id, &[\"Id\", \"Name\"]) {","highlight_start":47,"highlight_end":62}],"label":"expected `Option<Vec<String>>`, found `&[&str; 2]`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":4658,"byte_end":4661,"line_start":143,"line_end":143,"column_start":28,"column_end":31,"is_primary":false,"text":[{"text":"    let get_result = match get(\"Account\", id, &[\"Id\", \"Name\"]) {","highlight_start":28,"highlight_end":31}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"  expected enum `std::option::Option<Vec<std::string::String>>`\nfound reference `&[&str; 2]`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"/home/runner/work/busbar-sf-api/busbar-sf-api/crates/sf-guest-sdk/src/lib.rs","byte_start":10478,"byte_end":10481,"line_start":270,"line_end":270,"column_start":8,"column_end":11,"is_primary":true,"text":[{"text":"pub fn get(","highlight_start":8,"highlight_end":11}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:143:47\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m143\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let get_result = match get(\"Account\", id, &[\"Id\", \"Name\"]) {\n    \u001b[1m\u001b[94m|\u001b[0m                            \u001b[1m\u001b[94m---\u001b[0m                \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Option<Vec<String>>`, found `&[&str; 2]`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                            \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                            \u001b[1m\u001b[94marguments to this function are incorrect\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m:   expected enum `\u001b[1m\u001b[35mstd::option::Option<Vec<std::string::String>>\u001b[0m`\n            found reference `\u001b[1m\u001b[35m&[&str; 2]\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: function defined here\n   \u001b[1m\u001b[94m--> \u001b[0m/home/runner/work/busbar-sf-api/busbar-sf-api/crates/sf-guest-sdk/src/lib.rs:270:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m270\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn get(\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"struct `busbar_sf_guest_sdk::CompositeRequest` has no field named `collate_subrequests`","code":{"code":"E0560","explanation":"An unknown field was specified into a structure.\n\nErroneous code example:\n\n```compile_fail,E0560\nstruct Simba {\n    mother: u32,\n}\n\nlet s = Simba { mother: 1, father: 0 };\n// error: structure `Simba` has no field named `father`\n```\n\nVerify you didn't misspell the field's name or that the field exists. Example:\n\n```\nstruct Simba {\n    mother: u32,\n    father: u32,\n}\n\nlet s = Simba { mother: 1, father: 0 }; // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":7332,"byte_end":7351,"line_start":216,"line_end":216,"column_start":9,"column_end":28,"is_primary":true,"text":[{"text":"        collate_subrequests: false,","highlight_start":9,"highlight_end":28}],"label":"`busbar_sf_guest_sdk::CompositeRequest` does not have this field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"all struct fields are already assigned","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0560]\u001b[0m\u001b[1m: struct `busbar_sf_guest_sdk::CompositeRequest` has no field named `collate_subrequests`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:216:9\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m216\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         collate_subrequests: false,\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91m`busbar_sf_guest_sdk::CompositeRequest` does not have this field\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: all struct fields are already assigned\n\n"}
{"$message_type":"diagnostic","message":"struct `busbar_sf_guest_sdk::CompositeBatchSubrequest` has no field named `binary_part_name`","code":{"code":"E0560","explanation":"An unknown field was specified into a structure.\n\nErroneous code example:\n\n```compile_fail,E0560\nstruct Simba {\n    mother: u32,\n}\n\nlet s = Simba { mother: 1, father: 0 };\n// error: structure `Simba` has no field named `father`\n```\n\nVerify you didn't misspell the field's name or that the field exists. Example:\n\n```\nstruct Simba {\n    mother: u32,\n    father: u32,\n}\n\nlet s = Simba { mother: 1, father: 0 }; // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":9372,"byte_end":9388,"line_start":269,"line_end":269,"column_start":13,"column_end":29,"is_primary":true,"text":[{"text":"            binary_part_name: None,","highlight_start":13,"highlight_end":29}],"label":"`busbar_sf_guest_sdk::CompositeBatchSubrequest` does not have this field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"all struct fields are already assigned","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0560]\u001b[0m\u001b[1m: struct `busbar_sf_guest_sdk::CompositeBatchSubrequest` has no field named `binary_part_name`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:269:13\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m269\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             binary_part_name: None,\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91m`busbar_sf_guest_sdk::CompositeBatchSubrequest` does not have this field\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: all struct fields are already assigned\n\n"}
{"$message_type":"diagnostic","message":"struct `busbar_sf_guest_sdk::CompositeBatchSubrequest` has no field named `binary_part_name_alias`","code":{"code":"E0560","explanation":"An unknown field was specified into a structure.\n\nErroneous code example:\n\n```compile_fail,E0560\nstruct Simba {\n    mother: u32,\n}\n\nlet s = Simba { mother: 1, father: 0 };\n// error: structure `Simba` has no field named `father`\n```\n\nVerify you didn't misspell the field's name or that the field exists. Example:\n\n```\nstruct Simba {\n    mother: u32,\n    father: u32,\n}\n\nlet s = Simba { mother: 1, father: 0 }; // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":9408,"byte_end":9430,"line_start":270,"line_end":270,"column_start":13,"column_end":35,"is_primary":true,"text":[{"text":"            binary_part_name_alias: None,","highlight_start":13,"highlight_end":35}],"label":"`busbar_sf_guest_sdk::CompositeBatchSubrequest` does not have this field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"all struct fields are already assigned","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0560]\u001b[0m\u001b[1m: struct `busbar_sf_guest_sdk::CompositeBatchSubrequest` has no field named `binary_part_name_alias`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:270:13\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m270\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             binary_part_name_alias: None,\n    \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91m`busbar_sf_guest_sdk::CompositeBatchSubrequest` does not have this field\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: all struct fields are already assigned\n\n"}
{"$message_type":"diagnostic","message":"struct `busbar_sf_guest_sdk::CompositeBatchRequest` has no field named `batch_requests`","code":{"code":"E0560","explanation":"An unknown field was specified into a structure.\n\nErroneous code example:\n\n```compile_fail,E0560\nstruct Simba {\n    mother: u32,\n}\n\nlet s = Simba { mother: 1, father: 0 };\n// error: structure `Simba` has no field named `father`\n```\n\nVerify you didn't misspell the field's name or that the field exists. Example:\n\n```\nstruct Simba {\n    mother: u32,\n    father: u32,\n}\n\nlet s = Simba { mother: 1, father: 0 }; // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":9550,"byte_end":9564,"line_start":276,"line_end":276,"column_start":9,"column_end":23,"is_primary":true,"text":[{"text":"        batch_requests: subrequests,","highlight_start":9,"highlight_end":23}],"label":"`busbar_sf_guest_sdk::CompositeBatchRequest` does not have this field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `subrequests`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0560]\u001b[0m\u001b[1m: struct `busbar_sf_guest_sdk::CompositeBatchRequest` has no field named `batch_requests`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:276:9\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m276\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         batch_requests: subrequests,\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91m`busbar_sf_guest_sdk::CompositeBatchRequest` does not have this field\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `subrequests`\n\n"}
{"$message_type":"diagnostic","message":"missing field `sobject` in initializer of `busbar_sf_guest_sdk::CompositeTreeRequest`","code":{"code":"E0063","explanation":"A struct's or struct-like enum variant's field was not provided.\n\nErroneous code example:\n\n```compile_fail,E0063\nstruct Foo {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let x = Foo { x: 0 }; // error: missing field: `y`\n}\n```\n\nEach field should be specified exactly once. Example:\n\n```\nstruct Foo {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let x = Foo { x: 0, y: 0 }; // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":10822,"byte_end":10842,"line_start":309,"line_end":309,"column_start":19,"column_end":39,"is_primary":true,"text":[{"text":"    let request = CompositeTreeRequest {","highlight_start":19,"highlight_end":39}],"label":"missing `sobject`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0063]\u001b[0m\u001b[1m: missing field `sobject` in initializer of `busbar_sf_guest_sdk::CompositeTreeRequest`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:309:19\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m309\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let request = CompositeTreeRequest {\n    \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmissing `sobject`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 1 argument but 2 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":11429,"byte_end":11438,"line_start":327,"line_end":327,"column_start":26,"column_end":35,"is_primary":false,"text":[{"text":"    match composite_tree(\"Account\", &request) {","highlight_start":26,"highlight_end":35}],"label":"unexpected argument #1 of type `&'static str`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":11414,"byte_end":11428,"line_start":327,"line_end":327,"column_start":11,"column_end":25,"is_primary":true,"text":[{"text":"    match composite_tree(\"Account\", &request) {","highlight_start":11,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"/home/runner/work/busbar-sf-api/busbar-sf-api/crates/sf-guest-sdk/src/lib.rs","byte_start":13583,"byte_end":13597,"line_start":371,"line_end":371,"column_start":8,"column_end":22,"is_primary":true,"text":[{"text":"pub fn composite_tree(request: &CompositeTreeRequest) -> Result<CompositeTreeResponse, Error> {","highlight_start":8,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"remove the extra argument","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":11429,"byte_end":11440,"line_start":327,"line_end":327,"column_start":26,"column_end":37,"is_primary":true,"text":[{"text":"    match composite_tree(\"Account\", &request) {","highlight_start":26,"highlight_end":37}],"label":null,"suggested_replacement":"","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0061]\u001b[0m\u001b[1m: this function takes 1 argument but 2 arguments were supplied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:327:11\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m327\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     match composite_tree(\"Account\", &request) {\n    \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[94m---------\u001b[0m \u001b[1m\u001b[94munexpected argument #1 of type `&'static str`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: function defined here\n   \u001b[1m\u001b[94m--> \u001b[0m/home/runner/work/busbar-sf-api/busbar-sf-api/crates/sf-guest-sdk/src/lib.rs:371:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m371\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn composite_tree(request: &CompositeTreeRequest) -> Result<CompositeTreeResponse, Error> {\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: remove the extra argument\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m327\u001b[0m \u001b[91m- \u001b[0m    match composite_tree(\u001b[91m\"Account\", \u001b[0m&request) {\n\u001b[1m\u001b[94m327\u001b[0m \u001b[92m+ \u001b[0m    match composite_tree(&request) {\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":12957,"byte_end":12965,"line_start":368,"line_end":368,"column_start":59,"column_end":67,"is_primary":true,"text":[{"text":"    let create_results = match create_multiple(\"Account\", &records, false) {","highlight_start":59,"highlight_end":67}],"label":"expected `Vec<Value>`, found `&Vec<Value>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":12930,"byte_end":12945,"line_start":368,"line_end":368,"column_start":32,"column_end":47,"is_primary":false,"text":[{"text":"    let create_results = match create_multiple(\"Account\", &records, false) {","highlight_start":32,"highlight_end":47}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Vec<_>`\nfound reference `&Vec<_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"/home/runner/work/busbar-sf-api/busbar-sf-api/crates/sf-guest-sdk/src/lib.rs","byte_start":13814,"byte_end":13829,"line_start":376,"line_end":376,"column_start":8,"column_end":23,"is_primary":true,"text":[{"text":"pub fn create_multiple(","highlight_start":8,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider removing the borrow","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":12957,"byte_end":12958,"line_start":368,"line_end":368,"column_start":59,"column_end":60,"is_primary":true,"text":[{"text":"    let create_results = match create_multiple(\"Account\", &records, false) {","highlight_start":59,"highlight_end":60}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:368:59\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m368\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let create_results = match create_multiple(\"Account\", &records, false) {\n    \u001b[1m\u001b[94m|\u001b[0m                                \u001b[1m\u001b[94m---------------\u001b[0m            \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Vec<Value>`, found `&Vec<Value>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                \u001b[1m\u001b[94marguments to this function are incorrect\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `Vec<_>`\n            found reference `\u001b[1m\u001b[35m&\u001b[0mVec<_>`\n\u001b[1m\u001b[92mnote\u001b[0m: function defined here\n   \u001b[1m\u001b[94m--> \u001b[0m/home/runner/work/busbar-sf-api/busbar-sf-api/crates/sf-guest-sdk/src/lib.rs:376:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m376\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn create_multiple(\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider removing the borrow\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m368\u001b[0m \u001b[91m- \u001b[0m    let create_results = match create_multiple(\"Account\", \u001b[91m&\u001b[0mrecords, false) {\n\u001b[1m\u001b[94m368\u001b[0m \u001b[92m+ \u001b[0m    let create_results = match create_multiple(\"Account\", records, false) {\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"arguments to this function are incorrect","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":13281,"byte_end":13293,"line_start":379,"line_end":379,"column_start":29,"column_end":41,"is_primary":true,"text":[{"text":"    let get_results = match get_multiple(\"Account\", &ids, &[\"Id\", \"Name\"]) {","highlight_start":29,"highlight_end":41}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected `Vec<String>`, found `&Vec<String>`","code":null,"level":"note","spans":[{"file_name":"src/lib.rs","byte_start":13305,"byte_end":13309,"line_start":379,"line_end":379,"column_start":53,"column_end":57,"is_primary":true,"text":[{"text":"    let get_results = match get_multiple(\"Account\", &ids, &[\"Id\", \"Name\"]) {","highlight_start":53,"highlight_end":57}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"expected struct `Vec<_>`\nfound reference `&Vec<_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"expected `Vec<String>`, found `&[&str; 2]`","code":null,"level":"note","spans":[{"file_name":"src/lib.rs","byte_start":13311,"byte_end":13326,"line_start":379,"line_end":379,"column_start":59,"column_end":74,"is_primary":true,"text":[{"text":"    let get_results = match get_multiple(\"Account\", &ids, &[\"Id\", \"Name\"]) {","highlight_start":59,"highlight_end":74}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"expected struct `Vec<std::string::String>`\nfound reference `&[&str; 2]`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"/home/runner/work/busbar-sf-api/busbar-sf-api/crates/sf-guest-sdk/src/lib.rs","byte_start":14626,"byte_end":14638,"line_start":404,"line_end":404,"column_start":8,"column_end":20,"is_primary":true,"text":[{"text":"pub fn get_multiple(","highlight_start":8,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider removing the borrow","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":13305,"byte_end":13306,"line_start":379,"line_end":379,"column_start":53,"column_end":54,"is_primary":true,"text":[{"text":"    let get_results = match get_multiple(\"Account\", &ids, &[\"Id\", \"Name\"]) {","highlight_start":53,"highlight_end":54}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: arguments to this function are incorrect\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:379:29\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m379\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let get_results = match get_multiple(\"Account\", &ids, &[\"Id\", \"Name\"]) {\n    \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[91m^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: expected `Vec<String>`, found `&Vec<String>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:379:53\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m379\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let get_results = match get_multiple(\"Account\", &ids, &[\"Id\", \"Name\"]) {\n    \u001b[1m\u001b[94m|\u001b[0m                                                     \u001b[1m\u001b[92m^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `Vec<_>`\n            found reference `\u001b[1m\u001b[35m&\u001b[0mVec<_>`\n\u001b[1m\u001b[92mnote\u001b[0m: expected `Vec<String>`, found `&[&str; 2]`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:379:59\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m379\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let get_results = match get_multiple(\"Account\", &ids, &[\"Id\", \"Name\"]) {\n    \u001b[1m\u001b[94m|\u001b[0m                                                           \u001b[1m\u001b[92m^^^^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mVec<std::string::String>\u001b[0m`\n            found reference `\u001b[1m\u001b[35m&[&str; 2]\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: function defined here\n   \u001b[1m\u001b[94m--> \u001b[0m/home/runner/work/busbar-sf-api/busbar-sf-api/crates/sf-guest-sdk/src/lib.rs:404:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m404\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn get_multiple(\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider removing the borrow\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m379\u001b[0m \u001b[91m- \u001b[0m    let get_results = match get_multiple(\"Account\", \u001b[91m&\u001b[0mids, &[\"Id\", \"Name\"]) {\n\u001b[1m\u001b[94m379\u001b[0m \u001b[92m+ \u001b[0m    let get_results = match get_multiple(\"Account\", ids, &[\"Id\", \"Name\"]) {\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":13842,"byte_end":13857,"line_start":396,"line_end":396,"column_start":59,"column_end":74,"is_primary":true,"text":[{"text":"    let update_results = match update_multiple(\"Account\", &update_records, false) {","highlight_start":59,"highlight_end":74}],"label":"expected `Vec<UpdateMultipleRecord>`, found `&Vec<Value>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":13815,"byte_end":13830,"line_start":396,"line_end":396,"column_start":32,"column_end":47,"is_primary":false,"text":[{"text":"    let update_results = match update_multiple(\"Account\", &update_records, false) {","highlight_start":32,"highlight_end":47}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Vec<UpdateMultipleRecord>`\nfound reference `&Vec<Value>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"/home/runner/work/busbar-sf-api/busbar-sf-api/crates/sf-guest-sdk/src/lib.rs","byte_start":14223,"byte_end":14238,"line_start":390,"line_end":390,"column_start":8,"column_end":23,"is_primary":true,"text":[{"text":"pub fn update_multiple(","highlight_start":8,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:396:59\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m396\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let update_results = match update_multiple(\"Account\", &update_records, false) {\n    \u001b[1m\u001b[94m|\u001b[0m                                \u001b[1m\u001b[94m---------------\u001b[0m            \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Vec<UpdateMultipleRecord>`, found `&Vec<Value>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                                \u001b[1m\u001b[94marguments to this function are incorrect\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `Vec<\u001b[1m\u001b[35mUpdateMultipleRecord\u001b[0m>`\n            found reference `\u001b[1m\u001b[35m&\u001b[0mVec<\u001b[1m\u001b[35mValue\u001b[0m>`\n\u001b[1m\u001b[92mnote\u001b[0m: function defined here\n   \u001b[1m\u001b[94m--> \u001b[0m/home/runner/work/busbar-sf-api/busbar-sf-api/crates/sf-guest-sdk/src/lib.rs:390:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m390\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn update_multiple(\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 2 arguments but 3 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":14207,"byte_end":14211,"line_start":408,"line_end":408,"column_start":59,"column_end":63,"is_primary":false,"text":[{"text":"    let delete_results = match delete_multiple(\"Account\", &ids, false) {","highlight_start":59,"highlight_end":63}],"label":"unexpected argument #2 of type `&Vec<std::string::String>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":14180,"byte_end":14195,"line_start":408,"line_end":408,"column_start":32,"column_end":47,"is_primary":true,"text":[{"text":"    let delete_results = match delete_multiple(\"Account\", &ids, false) {","highlight_start":32,"highlight_end":47}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected `Vec<String>`, found `&str`","code":null,"level":"note","spans":[{"file_name":"src/lib.rs","byte_start":14196,"byte_end":14205,"line_start":408,"line_end":408,"column_start":48,"column_end":57,"is_primary":true,"text":[{"text":"    let delete_results = match delete_multiple(\"Account\", &ids, false) {","highlight_start":48,"highlight_end":57}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"expected struct `Vec<std::string::String>`\nfound reference `&'static str`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"/home/runner/work/busbar-sf-api/busbar-sf-api/crates/sf-guest-sdk/src/lib.rs","byte_start":15005,"byte_end":15020,"line_start":418,"line_end":418,"column_start":8,"column_end":23,"is_primary":true,"text":[{"text":"pub fn delete_multiple(","highlight_start":8,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"remove the extra argument","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":14205,"byte_end":14211,"line_start":408,"line_end":408,"column_start":57,"column_end":63,"is_primary":true,"text":[{"text":"    let delete_results = match delete_multiple(\"Account\", &ids, false) {","highlight_start":57,"highlight_end":63}],"label":null,"suggested_replacement":"","suggestion_applicability":"HasPlaceholders","expansion":null},{"file_name":"src/lib.rs","byte_start":14196,"byte_end":14205,"line_start":408,"line_end":408,"column_start":48,"column_end":57,"is_primary":true,"text":[{"text":"    let delete_results = match delete_multiple(\"Account\", &ids, false) {","highlight_start":48,"highlight_end":57}],"label":null,"suggested_replacement":"/* Vec<std::string::String> */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0061]\u001b[0m\u001b[1m: this function takes 2 arguments but 3 arguments were supplied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:408:32\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m408\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let delete_results = match delete_multiple(\"Account\", &ids, false) {\n    \u001b[1m\u001b[94m|\u001b[0m                                \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m            \u001b[1m\u001b[94m----\u001b[0m \u001b[1m\u001b[94munexpected argument #2 of type `&Vec<std::string::String>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: expected `Vec<String>`, found `&str`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:408:48\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m408\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let delete_results = match delete_multiple(\"Account\", &ids, false) {\n    \u001b[1m\u001b[94m|\u001b[0m                                                \u001b[1m\u001b[92m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mVec<std::string::String>\u001b[0m`\n            found reference `\u001b[1m\u001b[35m&'static str\u001b[0m`\n\u001b[1m\u001b[92mnote\u001b[0m: function defined here\n   \u001b[1m\u001b[94m--> \u001b[0m/home/runner/work/busbar-sf-api/busbar-sf-api/crates/sf-guest-sdk/src/lib.rs:418:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m418\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn delete_multiple(\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: remove the extra argument\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m408\u001b[0m \u001b[91m- \u001b[0m    let delete_results = match delete_multiple(\u001b[91m\"Account\", &ids\u001b[0m, false) {\n\u001b[1m\u001b[94m408\u001b[0m \u001b[92m+ \u001b[0m    let delete_results = match delete_multiple(\u001b[92m/* Vec<std::string::String> */\u001b[0m, false) {\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no field `list_views` on type `ListViewsResult`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":18580,"byte_end":18590,"line_start":529,"line_end":529,"column_start":40,"column_end":50,"is_primary":true,"text":[{"text":"            \"list_views_count\": result.list_views.len(),","highlight_start":40,"highlight_end":50}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"a field with a similar name exists","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":18580,"byte_end":18590,"line_start":529,"line_end":529,"column_start":40,"column_end":50,"is_primary":true,"text":[{"text":"            \"list_views_count\": result.list_views.len(),","highlight_start":40,"highlight_end":50}],"label":null,"suggested_replacement":"listviews","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `list_views` on type `ListViewsResult`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:529:40\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m529\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             \"list_views_count\": result.list_views.len(),\n    \u001b[1m\u001b[94m|\u001b[0m                                        \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: a field with a similar name exists\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m529\u001b[0m \u001b[91m- \u001b[0m            \"list_views_count\": result.\u001b[91mlist_views\u001b[0m.len(),\n\u001b[1m\u001b[94m529\u001b[0m \u001b[92m+ \u001b[0m            \"list_views_count\": result.\u001b[92mlistviews\u001b[0m.len(),\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no field `search_records` on type `Value`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":23327,"byte_end":23341,"line_start":661,"line_end":661,"column_start":44,"column_end":58,"is_primary":true,"text":[{"text":"            \"search_records_count\": result.search_records.len(),","highlight_start":44,"highlight_end":58}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `search_records` on type `Value`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:661:44\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m661\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             \"search_records_count\": result.search_records.len(),\n    \u001b[1m\u001b[94m|\u001b[0m                                            \u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 5 arguments but 1 argument was supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":27700,"byte_end":27717,"line_start":779,"line_end":779,"column_start":43,"column_end":60,"is_primary":false,"text":[{"text":"    let job = match bulk_create_ingest_job(&create_request) {","highlight_start":43,"highlight_end":60}],"label":"multiple arguments are missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":27678,"byte_end":27700,"line_start":779,"line_end":779,"column_start":21,"column_end":43,"is_primary":true,"text":[{"text":"    let job = match bulk_create_ingest_job(&create_request) {","highlight_start":21,"highlight_end":43}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"/home/runner/work/busbar-sf-api/busbar-sf-api/crates/sf-guest-sdk/src/lib.rs","byte_start":21946,"byte_end":21968,"line_start":615,"line_end":615,"column_start":8,"column_end":30,"is_primary":true,"text":[{"text":"pub fn bulk_create_ingest_job(","highlight_start":8,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the arguments","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":27700,"byte_end":27717,"line_start":779,"line_end":779,"column_start":43,"column_end":60,"is_primary":true,"text":[{"text":"    let job = match bulk_create_ingest_job(&create_request) {","highlight_start":43,"highlight_end":60}],"label":null,"suggested_replacement":"(&create_request, /* &str */, /* std::option::Option<std::string::String> */, /* &str */, /* &str */)","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0061]\u001b[0m\u001b[1m: this function takes 5 arguments but 1 argument was supplied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:779:21\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m779\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let job = match bulk_create_ingest_job(&create_request) {\n    \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[1m\u001b[94m-----------------\u001b[0m \u001b[1m\u001b[94mmultiple arguments are missing\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: function defined here\n   \u001b[1m\u001b[94m--> \u001b[0m/home/runner/work/busbar-sf-api/busbar-sf-api/crates/sf-guest-sdk/src/lib.rs:615:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m615\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn bulk_create_ingest_job(\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: provide the arguments\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m779\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    let job = match bulk_create_ingest_job(&create_request\u001b[92m, /* &str */, /* std::option::Option<std::string::String> */, /* &str */, /* &str */\u001b[0m) {\n    \u001b[1m\u001b[94m|\u001b[0m                                                           \u001b[92m++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find function `bulk_create_query_job` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"/home/runner/work/busbar-sf-api/busbar-sf-api/crates/sf-guest-sdk/src/lib.rs","byte_start":24775,"byte_end":24850,"line_start":714,"line_end":714,"column_start":1,"column_end":76,"is_primary":false,"text":[{"text":"pub fn bulk_abort_query_job(job_id: &str) -> Result<BulkJobResponse, Error> {","highlight_start":1,"highlight_end":76}],"label":"similarly named function `bulk_abort_query_job` defined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":29227,"byte_end":29248,"line_start":829,"line_end":829,"column_start":11,"column_end":32,"is_primary":true,"text":[{"text":"    match bulk_create_query_job(&request) {","highlight_start":11,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"a function with a similar name exists","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":29227,"byte_end":29248,"line_start":829,"line_end":829,"column_start":11,"column_end":32,"is_primary":true,"text":[{"text":"    match bulk_create_query_job(&request) {","highlight_start":11,"highlight_end":32}],"label":null,"suggested_replacement":"bulk_abort_query_job","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find function `bulk_create_query_job` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:829:11\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m829\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     match bulk_create_query_job(&request) {\n    \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mhelp: a function with a similar name exists: `bulk_abort_query_job`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/home/runner/work/busbar-sf-api/busbar-sf-api/crates/sf-guest-sdk/src/lib.rs:714:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m714\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn bulk_abort_query_job(job_id: &str) -> Result<BulkJobResponse, Error> {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m---------------------------------------------------------------------------\u001b[0m \u001b[1m\u001b[94msimilarly named function `bulk_abort_query_job` defined here\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":29608,"byte_end":29609,"line_start":840,"line_end":840,"column_start":43,"column_end":44,"is_primary":true,"text":[{"text":"        Err(e) => Ok(Json(TestResult::err(e.to_string()))),","highlight_start":43,"highlight_end":44}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:840:43\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m840\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Err(e) => Ok(Json(TestResult::err(e.to_string()))),\n    \u001b[1m\u001b[94m|\u001b[0m                                           \u001b[1m\u001b[91m^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find function `execute_anonymous_apex` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":30651,"byte_end":30663,"line_start":871,"line_end":871,"column_start":1,"column_end":13,"is_primary":false,"text":[{"text":"#[plugin_fn]","highlight_start":1,"highlight_end":13}],"label":"similarly named function `test_execute_anonymous_apex` defined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":30651,"byte_end":30663,"line_start":871,"line_end":871,"column_start":1,"column_end":13,"is_primary":false,"text":[{"text":"#[plugin_fn]","highlight_start":1,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[plugin_fn]","def_site_span":{"file_name":"/home/runner/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/extism-pdk-derive-1.4.1/src/lib.rs","byte_start":824,"byte_end":941,"line_start":24,"line_end":27,"column_start":1,"column_end":29,"is_primary":false,"text":[{"text":"pub fn plugin_fn(","highlight_start":1,"highlight_end":18},{"text":"    _attr: proc_macro::TokenStream,","highlight_start":1,"highlight_end":36},{"text":"    item: proc_macro::TokenStream,","highlight_start":1,"highlight_end":35},{"text":") -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/lib.rs","byte_start":31011,"byte_end":31033,"line_start":880,"line_end":880,"column_start":11,"column_end":33,"is_primary":true,"text":[{"text":"    match execute_anonymous_apex(apex_code) {","highlight_start":11,"highlight_end":33}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"a function with a similar name exists","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":31011,"byte_end":31033,"line_start":880,"line_end":880,"column_start":11,"column_end":33,"is_primary":true,"text":[{"text":"    match execute_anonymous_apex(apex_code) {","highlight_start":11,"highlight_end":33}],"label":null,"suggested_replacement":"test_execute_anonymous_apex","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find function `execute_anonymous_apex` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:880:11\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m871\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[plugin_fn]\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m------------\u001b[0m \u001b[1m\u001b[94msimilarly named function `test_execute_anonymous_apex` defined here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m880\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     match execute_anonymous_apex(apex_code) {\n    \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mhelp: a function with a similar name exists: `test_execute_anonymous_apex`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":31319,"byte_end":31320,"line_start":887,"line_end":887,"column_start":43,"column_end":44,"is_primary":true,"text":[{"text":"        Err(e) => Ok(Json(TestResult::err(e.to_string()))),","highlight_start":43,"highlight_end":44}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:887:43\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m887\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Err(e) => Ok(Json(TestResult::err(e.to_string()))),\n    \u001b[1m\u001b[94m|\u001b[0m                                           \u001b[1m\u001b[91m^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"this function takes 2 arguments but 1 argument was supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":32118,"byte_end":32128,"line_start":911,"line_end":911,"column_start":24,"column_end":34,"is_primary":false,"text":[{"text":"    match metadata_list(&[query]) {","highlight_start":24,"highlight_end":34}],"label":"argument #2 of type `std::option::Option<std::string::String>` is missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":32105,"byte_end":32118,"line_start":911,"line_end":911,"column_start":11,"column_end":24,"is_primary":true,"text":[{"text":"    match metadata_list(&[query]) {","highlight_start":11,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"/home/runner/work/busbar-sf-api/busbar-sf-api/crates/sf-guest-sdk/src/lib.rs","byte_start":29247,"byte_end":29260,"line_start":858,"line_end":858,"column_start":8,"column_end":21,"is_primary":true,"text":[{"text":"pub fn metadata_list(","highlight_start":8,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the argument","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":32118,"byte_end":32128,"line_start":911,"line_end":911,"column_start":24,"column_end":34,"is_primary":true,"text":[{"text":"    match metadata_list(&[query]) {","highlight_start":24,"highlight_end":34}],"label":null,"suggested_replacement":"(&[query], /* std::option::Option<std::string::String> */)","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0061]\u001b[0m\u001b[1m: this function takes 2 arguments but 1 argument was supplied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:911:11\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m911\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     match metadata_list(&[query]) {\n    \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[91m^^^^^^^^^^^^^\u001b[0m\u001b[1m\u001b[94m----------\u001b[0m \u001b[1m\u001b[94margument #2 of type `std::option::Option<std::string::String>` is missing\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: function defined here\n   \u001b[1m\u001b[94m--> \u001b[0m/home/runner/work/busbar-sf-api/busbar-sf-api/crates/sf-guest-sdk/src/lib.rs:858:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m858\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn metadata_list(\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: provide the argument\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m911\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    match metadata_list(&[query]\u001b[92m, /* std::option::Option<std::string::String> */\u001b[0m) {\n    \u001b[1m\u001b[94m|\u001b[0m                                 \u001b[92m++++++++++++++++++++++++++++++++++++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find function `get_sobject_layouts` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":33047,"byte_end":33059,"line_start":938,"line_end":938,"column_start":1,"column_end":13,"is_primary":false,"text":[{"text":"#[plugin_fn]","highlight_start":1,"highlight_end":13}],"label":"similarly named function `test_get_sobject_layouts` defined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":33047,"byte_end":33059,"line_start":938,"line_end":938,"column_start":1,"column_end":13,"is_primary":false,"text":[{"text":"#[plugin_fn]","highlight_start":1,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[plugin_fn]","def_site_span":{"file_name":"/home/runner/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/extism-pdk-derive-1.4.1/src/lib.rs","byte_start":824,"byte_end":941,"line_start":24,"line_end":27,"column_start":1,"column_end":29,"is_primary":false,"text":[{"text":"pub fn plugin_fn(","highlight_start":1,"highlight_end":18},{"text":"    _attr: proc_macro::TokenStream,","highlight_start":1,"highlight_end":36},{"text":"    item: proc_macro::TokenStream,","highlight_start":1,"highlight_end":35},{"text":") -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/lib.rs","byte_start":33398,"byte_end":33417,"line_start":947,"line_end":947,"column_start":11,"column_end":30,"is_primary":true,"text":[{"text":"    match get_sobject_layouts(sobject) {","highlight_start":11,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"a function with a similar name exists","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":33398,"byte_end":33417,"line_start":947,"line_end":947,"column_start":11,"column_end":30,"is_primary":true,"text":[{"text":"    match get_sobject_layouts(sobject) {","highlight_start":11,"highlight_end":30}],"label":null,"suggested_replacement":"test_get_sobject_layouts","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find function `get_sobject_layouts` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:947:11\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m938\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[plugin_fn]\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m------------\u001b[0m \u001b[1m\u001b[94msimilarly named function `test_get_sobject_layouts` defined here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m947\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     match get_sobject_layouts(sobject) {\n    \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mhelp: a function with a similar name exists: `test_get_sobject_layouts`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":33560,"byte_end":33561,"line_start":949,"line_end":949,"column_start":67,"column_end":68,"is_primary":false,"text":[{"text":"            \"layouts_count\": result[\"layouts\"].as_array().map(|a| a.len()).unwrap_or(0),","highlight_start":67,"highlight_end":68}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":33557,"byte_end":33558,"line_start":949,"line_end":949,"column_start":64,"column_end":65,"is_primary":true,"text":[{"text":"            \"layouts_count\": result[\"layouts\"].as_array().map(|a| a.len()).unwrap_or(0),","highlight_start":64,"highlight_end":65}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":33558,"byte_end":33558,"line_start":949,"line_end":949,"column_start":65,"column_end":65,"is_primary":true,"text":[{"text":"            \"layouts_count\": result[\"layouts\"].as_array().map(|a| a.len()).unwrap_or(0),","highlight_start":65,"highlight_end":65}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:949:64\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m949\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             \"layouts_count\": result[\"layouts\"].as_array().map(|a| a.len()).unwrap_or(0),\n    \u001b[1m\u001b[94m|\u001b[0m                                                                \u001b[1m\u001b[91m^\u001b[0m  \u001b[1m\u001b[94m-\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m949\u001b[0m \u001b[1m\u001b[94m| \u001b[0m            \"layouts_count\": result[\"layouts\"].as_array().map(|a\u001b[92m: /* Type */\u001b[0m| a.len()).unwrap_or(0),\n    \u001b[1m\u001b[94m|\u001b[0m                                                                 \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":33640,"byte_end":33641,"line_start":951,"line_end":951,"column_start":43,"column_end":44,"is_primary":true,"text":[{"text":"        Err(e) => Ok(Json(TestResult::err(e.to_string()))),","highlight_start":43,"highlight_end":44}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:951:43\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m951\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Err(e) => Ok(Json(TestResult::err(e.to_string()))),\n    \u001b[1m\u001b[94m|\u001b[0m                                           \u001b[1m\u001b[91m^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find function `get_compact_layouts` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":33741,"byte_end":33753,"line_start":957,"line_end":957,"column_start":1,"column_end":13,"is_primary":false,"text":[{"text":"#[plugin_fn]","highlight_start":1,"highlight_end":13}],"label":"similarly named function `test_get_compact_layouts` defined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":33741,"byte_end":33753,"line_start":957,"line_end":957,"column_start":1,"column_end":13,"is_primary":false,"text":[{"text":"#[plugin_fn]","highlight_start":1,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[plugin_fn]","def_site_span":{"file_name":"/home/runner/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/extism-pdk-derive-1.4.1/src/lib.rs","byte_start":824,"byte_end":941,"line_start":24,"line_end":27,"column_start":1,"column_end":29,"is_primary":false,"text":[{"text":"pub fn plugin_fn(","highlight_start":1,"highlight_end":18},{"text":"    _attr: proc_macro::TokenStream,","highlight_start":1,"highlight_end":36},{"text":"    item: proc_macro::TokenStream,","highlight_start":1,"highlight_end":35},{"text":") -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/lib.rs","byte_start":34092,"byte_end":34111,"line_start":966,"line_end":966,"column_start":11,"column_end":30,"is_primary":true,"text":[{"text":"    match get_compact_layouts(sobject) {","highlight_start":11,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"a function with a similar name exists","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":34092,"byte_end":34111,"line_start":966,"line_end":966,"column_start":11,"column_end":30,"is_primary":true,"text":[{"text":"    match get_compact_layouts(sobject) {","highlight_start":11,"highlight_end":30}],"label":null,"suggested_replacement":"test_get_compact_layouts","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find function `get_compact_layouts` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:966:11\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m957\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[plugin_fn]\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m------------\u001b[0m \u001b[1m\u001b[94msimilarly named function `test_get_compact_layouts` defined here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m966\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     match get_compact_layouts(sobject) {\n    \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mhelp: a function with a similar name exists: `test_get_compact_layouts`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":34269,"byte_end":34270,"line_start":968,"line_end":968,"column_start":82,"column_end":83,"is_primary":false,"text":[{"text":"            \"compact_layouts_count\": result[\"compactLayouts\"].as_array().map(|a| a.len()).unwrap_or(0),","highlight_start":82,"highlight_end":83}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":34266,"byte_end":34267,"line_start":968,"line_end":968,"column_start":79,"column_end":80,"is_primary":true,"text":[{"text":"            \"compact_layouts_count\": result[\"compactLayouts\"].as_array().map(|a| a.len()).unwrap_or(0),","highlight_start":79,"highlight_end":80}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":34267,"byte_end":34267,"line_start":968,"line_end":968,"column_start":80,"column_end":80,"is_primary":true,"text":[{"text":"            \"compact_layouts_count\": result[\"compactLayouts\"].as_array().map(|a| a.len()).unwrap_or(0),","highlight_start":80,"highlight_end":80}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:968:79\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m968\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             \"compact_layouts_count\": result[\"compactLayouts\"].as_array().map(|a| a.len()).unwrap_or(0),\n    \u001b[1m\u001b[94m|\u001b[0m                                                                               \u001b[1m\u001b[91m^\u001b[0m  \u001b[1m\u001b[94m-\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m968\u001b[0m \u001b[1m\u001b[94m| \u001b[0m            \"compact_layouts_count\": result[\"compactLayouts\"].as_array().map(|a\u001b[92m: /* Type */\u001b[0m| a.len()).unwrap_or(0),\n    \u001b[1m\u001b[94m|\u001b[0m                                                                                \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":34349,"byte_end":34350,"line_start":970,"line_end":970,"column_start":43,"column_end":44,"is_primary":true,"text":[{"text":"        Err(e) => Ok(Json(TestResult::err(e.to_string()))),","highlight_start":43,"highlight_end":44}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:970:43\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m970\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Err(e) => Ok(Json(TestResult::err(e.to_string()))),\n    \u001b[1m\u001b[94m|\u001b[0m                                           \u001b[1m\u001b[91m^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find function `list_named_credentials` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":34630,"byte_end":34642,"line_start":980,"line_end":980,"column_start":1,"column_end":13,"is_primary":false,"text":[{"text":"#[plugin_fn]","highlight_start":1,"highlight_end":13}],"label":"similarly named function `test_list_named_credentials` defined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":34630,"byte_end":34642,"line_start":980,"line_end":980,"column_start":1,"column_end":13,"is_primary":false,"text":[{"text":"#[plugin_fn]","highlight_start":1,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[plugin_fn]","def_site_span":{"file_name":"/home/runner/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/extism-pdk-derive-1.4.1/src/lib.rs","byte_start":824,"byte_end":941,"line_start":24,"line_end":27,"column_start":1,"column_end":29,"is_primary":false,"text":[{"text":"pub fn plugin_fn(","highlight_start":1,"highlight_end":18},{"text":"    _attr: proc_macro::TokenStream,","highlight_start":1,"highlight_end":36},{"text":"    item: proc_macro::TokenStream,","highlight_start":1,"highlight_end":35},{"text":") -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/lib.rs","byte_start":34736,"byte_end":34758,"line_start":982,"line_end":982,"column_start":11,"column_end":33,"is_primary":true,"text":[{"text":"    match list_named_credentials() {","highlight_start":11,"highlight_end":33}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"a function with a similar name exists","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":34736,"byte_end":34758,"line_start":982,"line_end":982,"column_start":11,"column_end":33,"is_primary":true,"text":[{"text":"    match list_named_credentials() {","highlight_start":11,"highlight_end":33}],"label":null,"suggested_replacement":"test_list_named_credentials","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find function `list_named_credentials` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:982:11\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m980\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[plugin_fn]\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m------------\u001b[0m \u001b[1m\u001b[94msimilarly named function `test_list_named_credentials` defined here\u001b[0m\n\u001b[1m\u001b[94m981\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn test_list_named_credentials(_input: String) -> FnResult<Json<TestResult>> {\n\u001b[1m\u001b[94m982\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     match list_named_credentials() {\n    \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mhelp: a function with a similar name exists: `test_list_named_credentials`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":34861,"byte_end":34867,"line_start":984,"line_end":984,"column_start":34,"column_end":40,"is_primary":true,"text":[{"text":"            \"credentials_count\": result.len(),","highlight_start":34,"highlight_end":40}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:984:34\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m984\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             \"credentials_count\": result.len(),\n    \u001b[1m\u001b[94m|\u001b[0m                                  \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":34932,"byte_end":34933,"line_start":986,"line_end":986,"column_start":43,"column_end":44,"is_primary":true,"text":[{"text":"        Err(e) => Ok(Json(TestResult::err(e.to_string()))),","highlight_start":43,"highlight_end":44}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:986:43\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m986\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Err(e) => Ok(Json(TestResult::err(e.to_string()))),\n    \u001b[1m\u001b[94m|\u001b[0m                                           \u001b[1m\u001b[91m^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find function `get_named_credential` in this scope","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":35036,"byte_end":35048,"line_start":992,"line_end":992,"column_start":1,"column_end":13,"is_primary":false,"text":[{"text":"#[plugin_fn]","highlight_start":1,"highlight_end":13}],"label":"similarly named function `test_get_named_credential` defined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib.rs","byte_start":35036,"byte_end":35048,"line_start":992,"line_end":992,"column_start":1,"column_end":13,"is_primary":false,"text":[{"text":"#[plugin_fn]","highlight_start":1,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[plugin_fn]","def_site_span":{"file_name":"/home/runner/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/extism-pdk-derive-1.4.1/src/lib.rs","byte_start":824,"byte_end":941,"line_start":24,"line_end":27,"column_start":1,"column_end":29,"is_primary":false,"text":[{"text":"pub fn plugin_fn(","highlight_start":1,"highlight_end":18},{"text":"    _attr: proc_macro::TokenStream,","highlight_start":1,"highlight_end":36},{"text":"    item: proc_macro::TokenStream,","highlight_start":1,"highlight_end":35},{"text":") -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/lib.rs","byte_start":35379,"byte_end":35399,"line_start":1001,"line_end":1001,"column_start":11,"column_end":31,"is_primary":true,"text":[{"text":"    match get_named_credential(name) {","highlight_start":11,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"a function with a similar name exists","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":35379,"byte_end":35399,"line_start":1001,"line_end":1001,"column_start":11,"column_end":31,"is_primary":true,"text":[{"text":"    match get_named_credential(name) {","highlight_start":11,"highlight_end":31}],"label":null,"suggested_replacement":"test_get_named_credential","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find function `get_named_credential` in this scope\u001b[0m\n    \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:1001:11\n     \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m992\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[plugin_fn]\n     \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m------------\u001b[0m \u001b[1m\u001b[94msimilarly named function `test_get_named_credential` defined here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m1001\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     match get_named_credential(name) {\n     \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mhelp: a function with a similar name exists: `test_get_named_credential`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":35564,"byte_end":35565,"line_start":1005,"line_end":1005,"column_start":43,"column_end":44,"is_primary":true,"text":[{"text":"        Err(e) => Ok(Json(TestResult::err(e.to_string()))),","highlight_start":43,"highlight_end":44}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n    \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:1005:43\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1005\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         Err(e) => Ok(Json(TestResult::err(e.to_string()))),\n     \u001b[1m\u001b[94m|\u001b[0m                                           \u001b[1m\u001b[91m^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 36 previous errors; 1 warning emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: aborting due to 36 previous errors; 1 warning emitted\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0061, E0063, E0282, E0308, E0422, E0425, E0560, E0609.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mSome errors have detailed explanations: E0061, E0063, E0282, E0308, E0422, E0425, E0560, E0609.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0061`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mFor more information about an error, try `rustc --explain E0061`.\u001b[0m\n"}
